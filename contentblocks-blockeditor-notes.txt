+-------------------+
| BackOffice editor |
+-------------------+

To render and edit blocks and their properties in the BackOffice, we currently use NestedContent
behind the scenes. A proof of concept (PoC) has now been created to change this to the BlockEditor
of Umbraco. This works well, blocks can be created and their properties can be adjusted. After a
Save/Publish, the blocks are correctly reloaded. We have full control over the UI that we want to
put around a block, just like with NestedContent. In the PoC, the ContentBlocks UI has not yet been
implemented, but since this is a custom property editor we have full control over the UI so this is
simply a matter of porting over the existing UI elements.

+------------------------+
| Migrate property value |
+------------------------+

To retain content in all existing sites that use ContentBlocks, we will need to migrate the data
from the NestedContent format to the BlockEditor format. The format fortunately does not differ
much. The structure has been somewhat adjusted but the content data itself is actually the same.
See below for a comparison. There are more differences in the surrounding structure not visible
below, but at its core, it's about converting these 2 objects:

NestedContent
{
    "key": "5f78d877-258d-45a6-bb0c-4e1adeb42b81",
    "name": "Test",
    "ncContentTypeAlias": "exampleBlock",
    "title": "Test",
    "text": "<p><strong>Test</strong></p>\n<p><a href=\"/{localLink:umb://document/ce72d00f878a4e20b026b26ed9a136fb}\" title=\"Home\">Link</a></p>"
}

BlockEditor
{
    "contentTypeKey": "7a84d7fc-dcf7-466c-b52e-bc59b237949e",
    "udi": "umb://element/887f372b8b914b9b838ea50aeefe2708",
    "title": "Test",
    "text": "<p><strong>Test</strong></p>\n<p><a href=\"/{localLink:umb://document/ce72d00f878a4e20b026b26ed9a136fb}\" title=\"Home\">Link</a></p>"
}

As you can see, there are very few differences. NestedContent uses a doctype alias
(ncContentTypeAlias), BlockEditor uses a doctype key (contentTypeKey), but that's easy to convert.
Furthermore, NestedContent has a unique GUID (key), while BlockEditor uses a udi but that is
literally also a GUID with prefix "umb://element/" so it's also convertible 1 to 1. The content of
the content properties itself ("title" and "text" in this example) is exactly the same so we don't
have to do anything there.

A limitation we encountered is that the Block Editor does not support doctypes in which
NestedContent properties are embedded. Therefore, if there are existing doctypes that are used in
ContentBlocks with NestedContent datatypes, we will need to convert the NestedContent datatypes to
Umbraco.BlockListEditor datatypes that we can then use in the BlockEditor.

+---------------------+
| Front end rendering |
+---------------------+

For rendering in the front-end, the goal is that this remains exactly the same as now for the end
user. In ContentBlocks, we always used the ModelsBuilder classes, and the BlockEditor should also
support this. We will need to make an adjustment in our PropertyValueConverter that converts the
property value to ModelsBuilder objects, but this should be able to happen in a similar way as we
are doing now, except that we will need to use BlockEditor C# code instead of the current
NestedContentSingleValueConverter to convert the JSON into ModelsBuilder instances.

I have expanded the PoC for this, and I see that from Umbraco 11, code is available to do this.
I can therefore now convert the blocks created in the back office into the correct ModelsBuilder
instances in the PropertyValueConverter. This is exactly what we need in ContentBlocks, so I can
create our own "IContentBlockViewModel" instances of it, which contains the ModelsBuilder object and
some extra properties (block id / layout id / definition id). In the PoC, I even managed to render
this now via Html.RenderContentBlocks(), so this works exactly the same for the end user and seems
to work already. I haven't tested all cases yet, but it looks very positive.
